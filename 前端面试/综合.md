## 目录

1. 你工作中遇到最难的问题是什么
2. 在工作中，你对团队最大的共享是什么
3. 两个页面怎么进行交互
4. 讲下前端开发中的热更新原理
5. 输入URL到页面渲染的整个流程
6. Vue和react的区别

#### 1. 你工作中遇到最难的问题是什么

首先我讲下，我最近做的一个项目吧！

我最近半年多一直在做一个项目是桌面客户端项目迭代，它是基于electron开发的。因为项目开发的时间比较久，一直在迭代。如果追溯到最开始的时候，应该算是4年前了。2020年之前，项目都是基于jquery+electron+Eui开发的。2020年后，项目使用了新的技术栈，基于react+umi+electron+rxd进行开发。如果说是开发新功能，那么都是基于react开发的，只要需求确定，原型设计都是确定的，有后端配合，业务开发是没有难度的。但是老项目上面改造一个新功能，起初我也觉得不难。后来我在改造中，我就遇到难题了。我遇到最大的问题是，没有后端配合，没有接口文档，没有需求文档。只有一个效果图，关键效果图还和原来的功能效果差距还很大。

于是，我去找产品，找开发要需求文档和接口文档。他们给我的答复是，都好多年了，我也不知道谁开发的，文档也没了。这样子，我就只能靠自己。如果直接开发，肯定会问题很大。我就照着原来的页面，开始点点点，理解原有的逻辑。点击的时候的报文，接口我记录下来，不一致的点，接口缺失的字段，或者没有的接口我都记录下来，然后整理了一份文档。发给了项目经理，产品经理，后端，把相关的人员都发了邮件确认。最后我再按照，我整理的需求，接口，先把可以做的功能开发。开发和领导确认同时进行，当我改造的差不多了，领导也安排好了配合的人员。

#### 2. 在工作中，你对团队最大的贡献是什么

主要分2方面：一方面是，积极学习新技术，这样子，在开发中遇到问题，遇到新的技术栈可以很快上手解决。还有一个是参与开发组件库。在之后的项目中，同事们用到了我开发的ui组件，成就感很大。还能避免重复造轮子，提升了团队效率。

#### 3. 两个页面怎么进行交互

这个问题分成单页面，多页面和iframe来写比较好。这三种都可以通过URL和浏览器存储来通讯，在iframe跨域的情况下可以使用postMessage，单页面就js层面状态管理，和组件间路由传参。

当然如果想玩的花，甚至可以服务端状态管理，靠http来通信。又比如ssr的话，部分状态也需要服务端来处理了。

1. 设置缓存，也就是A页面设置缓存，B页面取值
2. 通过url传参的方式
3. 通过路由的state模式传参
4. 通过发布订阅模式

#### 4. 讲下前端开发中的热更新原理

分析

1. 文件内容变更了，浏览器是怎么知道的呢？
2. css文件内容变更了，没有刷新页面 怎么加载最新的内容呢？

只要解决了上面两个问题，我们就算是完成了。因为剩下得就是编码了，这都好说。

文件变更了，我怎样通知浏览器？

1. 浏览器和服务器保持着连接。服务器有什么事儿直接通过当前的链接告诉浏览器就可以了。
    - 连接肯定是长连接，不然怎么实时通信。
    - 保持长连接有哪些方法呢？轮询？eventSorce？都不够好。
    - 有么有更好的方案呢？那就是：websocket。
    - 浏览器和服务器先建立好链接，服务器就可以直接通知到客户端了。这个时候无论是pc上还是手机上都可以随时根据需要刷新或者加载资源。
2. css更新，css本身是可以通过dom去操作的。浏览器只要知道是css更新了，直接重新加载当前的css文件就可以了。

#### 5. 输入URL到页面渲染的整个流程

首先是DNS查询，如果这一步做了智能DNS解析的话，会提供访问速度最快的IP地址回来。

DNS的作用就是通过域名查询到具体的IP。

因为IP存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个IP的别名，DNS就是去查询这个别名的真正名称是什么。

在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己做的。当你在浏览器中想访问www.baidu.com时，会进行一下操作：

1. 操作系统会首先在本地缓存中查询IP
2. 没有的话会去系统配置的DNS服务器中查询
3. 如果这时候还没得话，会直接去DNS根服务器查询，这一步查询会找出负责com这个一级域名的服务器
4. 然后去该服务器查询baidu这个二级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给www这个域名配置一个IP，然后还可以给别的三级域名配置一个IP

以上介绍的是DNS迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的DNS服务器做请求，得到结果后将数据返回给客户端。

PS：DNS是基于UDP做的查询，大家也可以考虑下为什么之前不考虑使用TCP去实现。

接下来是TCP握手，应用层会下发数据给传输层，这里TCP协议会指明两端的端口号，然后下发给网络层。网络层中的IP协议会确定IP地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

在这一部分中，可以详细说下TCP的握手情况以及TCP的一些特性。

当TCP握手结束后就会进行TLS握手，然后就开始正式的传输数据。

在这一部分中，可以详细说下TLS的握手情况以及两种加密方式的内容。

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个HTML文件。

首先浏览器会判断状态码是什么，如果是200那就继续解析，如果400或500的话就会报错，如果300的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据HTML构建DOM树，有CSS的话会去构建CSSOM树。如果遇到script标签的话，会判断是否存在async或者defer，前者会并行进行下载并执行JS，后者会先下载文件，然后等待HTML解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到JS执行完毕。遇到文件下载的会去下载文件，这里如果使用HTTP/2协议的话会极大的提高多图的下载效率。

CSSOM树和DOM树构建完成后会开始生成Render树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成Render树的过程中，浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了。

6. Vue和react的区别

1. 数据监听实现原理不同：

Vue通过getter/setter以及一些函数的劫持，能精确知道数据变化。

React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。为什么React不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用的时候更棒。

2. 数据流的不同

vue 2.x开始进制父子组件的双向数据流，而保留了组件和UI的数据绑定

React一直不支持双向绑定，提倡的是单向数据流，称之为onChange/setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

3. HoC和mixins

Vue组合不同功能的方式是通过mixin，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。

React组合不同功能的方式是通过HoC(高阶组件）。React最早也是使用mixins的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了mixinx转而使用HoC。高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。

4. 组件通信的区别

Vue中有三种方式可以实现组件通信：

- 父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；
- 子组件通过事件向父组件发送消息；
- 通过V2.2.0中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。

React中也有对应的三种方式：

父组件通过props可以向子组件传递数据或者回调；可以通过context进行跨层级的通信，这其实和provide/inject起到的作用差不多。React本身并不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数，但Vue更倾向于使用事件。在React中我们都是使用回调函数的，这可能是他们二者最大的区别。

5. 模板渲染方式的不同

在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。

在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要v-if来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。

举个例子，说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。

6. 渲染过程不同

Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。

如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。

7. 框架本质不同

Vue本质是MVVM框架，由MVC发展而来；

React是前端组件化框架，由后端组件化发展而来。

8. Vuex和Redux的区别

从表面上来说，store注入和使用方式有一些区别。在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。

从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用Vue的感觉。
