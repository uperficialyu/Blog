## 目录

1. 你工作中遇到最难的问题是什么
2. 在工作中，你对团队最大的共享是什么
3. 两个页面怎么进行交互
4. 讲下前端开发中的热更新原理
5. 输入URL到页面渲染的整个流程

#### 1. 你工作中遇到最难的问题是什么

首先我讲下，我最近做的一个项目吧！

我最近半年多一直在做一个项目是桌面客户端项目迭代，它是基于electron开发的。因为项目开发的时间比较久，一直在迭代。如果追溯到最开始的时候，应该算是4年前了。2020年之前，项目都是基于jquery+electron+Eui开发的。2020年后，项目使用了新的技术栈，基于react+umi+electron+rxd进行开发。如果说是开发新功能，那么都是基于react开发的，只要需求确定，原型设计都是确定的，有后端配合，业务开发是没有难度的。但是老项目上面改造一个新功能，起初我也觉得不难。后来我在改造中，我就遇到难题了。我遇到最大的问题是，没有后端配合，没有接口文档，没有需求文档。只有一个效果图，关键效果图还和原来的功能效果差距还很大。

于是，我去找产品，找开发要需求文档和接口文档。他们给我的答复是，都好多年了，我也不知道谁开发的，文档也没了。这样子，我就只能靠自己。如果直接开发，肯定会问题很大。我就照着原来的页面，开始点点点，理解原有的逻辑。点击的时候的报文，接口我记录下来，不一致的点，接口缺失的字段，或者没有的接口我都记录下来，然后整理了一份文档。发给了项目经理，产品经理，后端，把相关的人员都发了邮件确认。最后我再按照，我整理的需求，接口，先把可以做的功能开发。开发和领导确认同时进行，当我改造的差不多了，领导也安排好了配合的人员。

#### 2. 在工作中，你对团队最大的贡献是什么

主要分2方面：一方面是，积极学习新技术，这样子，在开发中遇到问题，遇到新的技术栈可以很快上手解决。还有一个是参与开发组件库。在之后的项目中，同事们用到了我开发的ui组件，成就感很大。还能避免重复造轮子，提升了团队效率。

#### 3. 两个页面怎么进行交互

这个问题分成单页面，多页面和iframe来写比较好。这三种都可以通过URL和浏览器存储来通讯，在iframe跨域的情况下可以使用postMessage，单页面就js层面状态管理，和组件间路由传参。

当然如果想玩的花，甚至可以服务端状态管理，靠http来通信。又比如ssr的话，部分状态也需要服务端来处理了。

1. 设置缓存，也就是A页面设置缓存，B页面取值
2. 通过url传参的方式
3. 通过路由的state模式传参
4. 通过发布订阅模式

#### 4. 讲下前端开发中的热更新原理

分析

1. 文件内容变更了，浏览器是怎么知道的呢？
2. css文件内容变更了，没有刷新页面 怎么加载最新的内容呢？

只要解决了上面两个问题，我们就算是完成了。因为剩下得就是编码了，这都好说。

文件变更了，我怎样通知浏览器？

1. 浏览器和服务器保持着连接。服务器有什么事儿直接通过当前的链接告诉浏览器就可以了。
    - 连接肯定是长连接，不然怎么实时通信。
    - 保持长连接有哪些方法呢？轮询？eventSorce？都不够好。
    - 有么有更好的方案呢？那就是：websocket。
    - 浏览器和服务器先建立好链接，服务器就可以直接通知到客户端了。这个时候无论是pc上还是手机上都可以随时根据需要刷新或者加载资源。
2. css更新，css本身是可以通过dom去操作的。浏览器只要知道是css更新了，直接重新加载当前的css文件就可以了。

#### 5. 输入URL到页面渲染的整个流程

首先是DNS查询，如果这一步做了智能DNS解析的话，会提供访问速度最快的IP地址回来。

DNS的作用就是通过域名查询到具体的IP。

因为IP存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个IP的别名，DNS就是去查询这个别名的真正名称是什么。

在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己做的。当你在浏览器中想访问www.baidu.com时，会进行一下操作：

1. 操作系统会首先在本地缓存中查询IP
2. 没有的话会去系统配置的DNS服务器中查询
3. 如果这时候还没得话，会直接去DNS根服务器查询，这一步查询会找出负责com这个一级域名的服务器
4. 然后去该服务器查询baidu这个二级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给www这个域名配置一个IP，然后还可以给别的三级域名配置一个IP

以上介绍的是DNS迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的DNS服务器做请求，得到结果后将数据返回给客户端。

PS：DNS是基于UDP做的查询，大家也可以考虑下为什么之前不考虑使用TCP去实现。

接下来是TCP握手，应用层会下发数据给传输层，这里TCP协议会指明两端的端口号，然后下发给网络层。网络层中的IP协议会确定IP地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

在这一部分中，可以详细说下TCP的握手情况以及TCP的一些特性。

当TCP握手结束后就会进行TLS握手，然后就开始正式的传输数据。

在这一部分中，可以详细说下TLS的握手情况以及两种加密方式的内容。

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个HTML文件。

首先浏览器会判断状态码是什么，如果是200那就继续解析，如果400或500的话就会报错，如果300的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据HTML构建DOM树，有CSS的话会去构建CSSOM树。如果遇到script标签的话，会判断是否存在async或者defer，前者会并行进行下载并执行JS，后者会先下载文件，然后等待HTML解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到JS执行完毕。遇到文件下载的会去下载文件，这里如果使用HTTP/2协议的话会极大的提高多图的下载效率。

CSSOM树和DOM树构建完成后会开始生成Render树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成Render树的过程中，浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了。
