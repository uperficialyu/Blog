## 目录

1. 讲下react生命周期
2. js的数据类型
3. 什么是闭包
4. Vue和react的区别

#### 1. 讲下react生命周期

React 16之后有三个⽣命周期被废弃(但并未删除)

- componentWillMount
- componentWillReceiveProps
- componentWillUpdate

官⽅计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，⽬的是为了向下兼容，但是对于开发者⽽⾔应该尽量避免使⽤他们，⽽是使⽤新增的⽣命周期函数替代它们。

⽬前React16.8+的⽣命周期分为三个阶段，分别是挂载阶段、更新阶段、卸载阶段。

挂载阶段：

- constructor：构造函数，最先被执⾏，我们通常在构造函数⾥初始化state对象或者给⾃定义⽅法绑定this；
- getDerivedStateFromProps：static getDerivedStateFromProps(nextProps, prevState)，这是个静态⽅法，当我们接收到新的属性想去修改我们state， 可以使⽤getDerivedStateFromProps
- render：render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑，可以返回原⽣的DOM、React组件、Fragment、Portals、字符串和数字、 Boolean和null等内容；
- componentDidMount：组件装载之后调⽤，此时我们可以获取到DOM节点并操作，⽐如对canvas，svg的操作，服务器请求，订阅都可以写在这个⾥⾯，但是记得在componentWillUnmount中取消订阅；

更新阶段：

- getDerivedStateFromProps: 此⽅法在更新个挂载阶段都可能会调⽤；
- shouldComponentUpdate：shouldComponentUpdate(nextProps, nextState)，有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回⼀个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true，我们通常利⽤此⽣命周期来优化React程序性能；
- render：更新阶段也会触发此⽣命周期；
- getSnapshotBeforeUpdate：getSnapshotBeforeUpdate(prevProps, prevState),这个⽅法在render之后，componentDidUpdate之前调⽤，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有⼀个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此⽣命周期必须与componentDidUpdate搭配使⽤；
- componentDidUpdate：componentDidUpdate(prevProps, prevState, snapshot)，该⽅法在getSnapshotBeforeUpdate⽅法之后被调⽤，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的，如果触发某些回调函数时需要⽤到DOM元素的状态，则将对⽐或计算的过程迁移⾄getSnapshotBeforeUpdate，然后在componentDidUpdate中统⼀触发回调或更新状态。

卸载阶段:

-componentWillUnmount：当我们的组件被卸载或者销毁了就会调⽤，我们可以在这个函数⾥去清除⼀些定时器，取消⽹络请求，清理⽆效的DOM元素等垃圾清理⼯作。

总结：

- componentWillMount：在渲染之前执行，用于根组件中的 App 级配置；
- componentDidMount：在第一次渲染之后执行，可以在这里做AJAX请求，DOM的操作或状态更新以及设置事件监听器；
- componentWillReceiveProps：在初始化render的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染
- shouldComponentUpdate：确定是否更新组件。默认情况下，它返回true。如果确定在state或props更新后组件不需要在重新渲染，则可以返回false，这是一个提高性能的方法；
- componentWillUpdate：在shouldComponentUpdate返回true确定要更新组件之前件之前执行；
- componentDidUpdate：它主要用于更新DOM以响应props或state更改；
- componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。

#### . js的数据类型

js中的数据类型主要分为2种：

1. 基本数据类型（值类型）
    - number（数字）
    - string（字符串）
    - boolean（布尔）
    - null（空）
    - undefind（未定义）
    - symbol（唯一值） ES6中新增的数据类型（不能被new） 创建唯一值Symbol(10)===Symbol(10):false
    - bigint（大数据值） ES6中新增的数据类型（不能被new） Number.MAX_SAFE_INTEGER（最大安全数）
2. 引用数据类型
    - object（对象）
    - Array（数组）
    - RegExp（正则）
    - Date（日期）
    - function（函数）

复杂数据类型存储在堆内存，存储的是地址。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。

#### 3. 什么是闭包

MDN上这么说：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

市面上大多认为：只有上下文不被释放才是闭包。

以下是我的观点：

说到闭包，不得不先提及javascript中函数执行的机制：在javascript语句执行过程中，有一个宿主执行环境，可以称之为执行上下文栈（ECS：Execution Context Stack），其中包含全局执行上下文（ECG：Execution Context Global）；而在函数执行语句被执行的时候，比如func();，会临时开辟一个新的执行上下文，可以称之为函数执行上下文（ECF：Execution Context Func）；无论哪种执行上下文，其中都包含了变量对象VO（Variable Object），标识了当前执行上下文中所拥有的所有变量；javascript语句执行过程中，依次压入当前语句所开辟的执行上下文，执行完毕后弹出；全局执行上下文ECG比较特殊，它默认被推入执行栈底，伴随整个执行周期，最后才被释放，而函数执行上下文在执行过程中，会被依次压入栈中执行，理论上执行完毕出栈；然而执行栈中存在作用域链的概念，在一个执行栈中可以引用自它之下到栈底的所有执行栈中的活动对象（AO：Active Object，当执行栈创建瞬间原有执行栈中的变量对象VO就成了AO），如果任一执行栈中的活动对象被其他执行栈引用，则该执行栈不能被释放（释放意味着执行栈销毁，变量对象被回收），这就形成了闭包，闭包的形成通常场景是外层函数执行返回结果为函数，并且该函数中引用了外层函数中的变量对象。

#### 4. Vue和react的区别

1. 数据监听实现原理不同：

Vue通过getter/setter以及一些函数的劫持，能精确知道数据变化。

React默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的VDOM的重新渲染。为什么React不精确监听数据变化呢？这是因为Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者没有好坏之分，Vue更加简单，而React构建大型应用的时候更棒。

2. 数据流的不同

vue 2.x开始进制父子组件的双向数据流，而保留了组件和UI的数据绑定

React一直不支持双向绑定，提倡的是单向数据流，称之为onChange/setState()模式。不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

3. HoC和mixins

Vue组合不同功能的方式是通过mixin，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。

React组合不同功能的方式是通过HoC(高阶组件）。React最早也是使用mixins的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了mixinx转而使用HoC。高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。

4. 组件通信的区别

Vue中有三种方式可以实现组件通信：

- 父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据；
- 子组件通过事件向父组件发送消息；
- 通过V2.2.0中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。

React中也有对应的三种方式：

父组件通过props可以向子组件传递数据或者回调；可以通过context进行跨层级的通信，这其实和provide/inject起到的作用差不多。React本身并不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数，但Vue更倾向于使用事件。在React中我们都是使用回调函数的，这可能是他们二者最大的区别。

5. 模板渲染方式的不同

在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。

在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要v-if来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。

举个例子，说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。

6. 渲染过程不同

Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。

如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。

7. 框架本质不同

Vue本质是MVVM框架，由MVC发展而来；

React是前端组件化框架，由后端组件化发展而来。

8. Vuex和Redux的区别

从表面上来说，store注入和使用方式有一些区别。在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。

从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用Vue的感觉。



1、	diff算法原理
3、	hooks
4、	http协议
5、	性能优化
6、	你遇到的最难的问题，技术上的
7、	微信的授权
8、	H5的性能优化
9、	重排和重绘
10、浏览器输入网址的过程
13、原型链
14、js的运行机制
15、解决跨域问题
16、后端cors，跨域后，前端怎么设置，后端可以拿到cookie
17、浏览器渲染机制

1、	自我介绍
2、	项目中最难的问题是什么
3、	ReactNative讲下
4、	工资要求
6、	性能优化
7、	你做的一些基础搭建
8、	你怎么带实习生的
