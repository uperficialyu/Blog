## 目录

1. 大数相加手写
2. 讲下你最近的项目
3. 如何做性能优化
4. 如何⽤webpack来优化前端性能

#### 1. 大数相加手写

JS在存放整数的时候是有一个安全范围的，一旦数字超过这个范围便会损失精度。

我们不能拿精度损失的数字进行运行，因为运算结果一样是会损失精度的。

所以，我们要用字符串来表示数据！（不会丢失精度）

方案1：

  ```javascript
  let a = "9007199254740991";
  let b = "1234567899999999999";

  function add(a, b) {
    // 取两个数字的最大长度
    let maxLength = Math.max(a.length, b.length);
    // 用0去补齐长度
    a = a.padStart(maxLength, 0);//"0009007199254740991"
    b = b.padStart(maxLength, 0);//"1234567899999999999"
    // 定义加法过程中需要用到的变量
    let t = 0;
    let f = 0;   // 进位
    let sum = "";
    for (let i = maxLength - 1; i >= 0; i--) {
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t / 10);
      sum = t % 10 + sum;
    }
    if (f == 1) {
      sum = "1" + sum;
    }
    return sum;
  }
  ```

方案2：

  ```javascript
  function sumBigNumber(a, b) {
    var res = '',
      temp = 0;
    a = a.split('');
    b = b.split('');
    while (a.length || b.length || temp) {
      temp += ~~a.pop() + ~~b.pop();
      res = (temp % 10) + res;
      temp = temp > 9;
    }
    return res.replace(/^0+/, '');
  }
  ```

1. 首先我们用字符串的形势来保存大数，就保证了其在数学表示上不会发生变化
2. 初始化res, temp变量来保存中间计算的结果，在将两个字符串split为数组，以便我们进行每一位的运算
3. 循环的第一次就是进行"个位"的运算，将二者最末尾的两个数相加，由于每一位数字是0-9，所以需要进行进位，在进过取余数操作后，将结果保留在个位
4. 判断temp是否大于10，若是则将temp赋值为true，等等，为什么要赋值成布尔值，不要着急，魔法即将发生
5. 在两个大数中的一个还有数字没有参与运算，或者前一次运算发生进位后，进行下一次循环
6. 接着除了对新的两个数字相加还要加上temp，若上次发生了进位，则此时temp为true，Js因为存在隐式转换，所以true转换为1，我们借用Js的类型转换，完成了逻辑上的逢10进1操作。Amazing
7. 接下来就是重复上述的操作，直到计算结束

#### 2. 讲下你最近的项目

我最近一个项目是一个金融的交易系统。项目团队前端10人，后端50多人。前端技术栈是多技术栈，新版本用的是React，老版本用的是Jquery。在团队中我是主力开发，主要是负责项目的组件开发，还有交易的业务开发。项目中采用的是一个类似low coding的解决方案。因为，我们需求变化不大，所以这样的一个解决方案，会提高开发效率，也会减少bug率，而且后期维护，也会方便很多。项目中使用的是json话配置，是因为，可以服务端进行动态的页面配置。

#### 3. 如何做性能优化

##### 减少请求资源大小或者次数

1. 尽量和并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）
    - 原因：主要是为了减少http请求次数以及减少请求资源的大小
    - 打包工具：webpack、gulp、grunt
2. 尽量所使用的字体图标或者SVG图标来代替传统png图
    - 因为字体图标或者SVG是矢量图，代码编写出来的，方大不会变形，而且渲染速度快
3. 采用图片的懒加载（延迟加载）
    - 目的为了，减少页面第一次加载过程中http的请求次数
    - 页面开始加载时不去发送http请求，而是放置一张占位图
    - 当页面加载完时，并且图片在可视区域再去请求加载图片信息
4. 能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件
    - 避免引入第三方大量的库。而自己却只是用里面的一个小功能
5. 使用雪碧图或者是说图片精灵
    - 把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用
    - 图片定位来讲小图展现在页面中（background-position:百分比，数值）
6. 减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果上设置不当，每次发送一个请求将会携带cookie
7. 前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml来说传输有这个优势
    - 目的：是数据处理方便，资源偏小
8. 前端与后端协商，合理使用keep-alive
9. 前端与服务器协商，使用响应资源的压缩
10. 避免使用iframe
    - 不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源
11. 在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意：这个缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据时，取得就是上一次缓存的数据。（注意：很少使用，一般都会清空。根据需求来做）

##### 代码优化相关

1. 在js中尽量减少闭包的使用
    - 原因：使用闭包后，闭包所在的上下文不会被释放
2. 减少对DOM操作，主要是减少DOM的重绘与回流（重排）
    - 关于重排（回流）的分离读写：如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）
3. 在js中避免嵌套循环和"死循环"(一旦遇到死循环，浏览器就会直接卡掉)
4. 把css放在body上，把js放在body下面
    - 让其先加载css（注意：这里关于优化没有多大关系）
5. 减少css表达式的使用
6. css选择器解析规则所示从右往左解析的。减少元素标签作为对后一个选择对象
7. 尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）
    - 注意：图层不要过多设置，否则不但效果没有达到反而更差了
8. 在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码
9. css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上
10. css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作
11. 使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画
    - 如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout
    - 代替setInterval定时器。因为setInterval定时器存在弊端：可能造成两个动画间隔时间缩短
12. 尽量减少使用递归。避免死递归
    - 解决：建议使用尾递归
13. 基于script标签下载js文件时，可以使用defer或者async来异步加载
14. 在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。
15. 在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码
16. 减少Flash的使用

##### 存储

1. 结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意：也有弊端）可以让一些不太会改变的静态资源做缓存。比如：一些图片，js，cs
2. 利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，
    - 避免向后台请求数据或者说在离线状态下做一些数据展示。

##### 其他优化

1. 避免使用iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源
2. 页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢
    - 那么，页面会在一段时间内处于阻塞状态。目的：为了解决请求数据不耽搁渲染，提高页面的渲染效率。
    - 解决方法：需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数
3. 页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）
    - 解决方法：只需要将音视频的preload=none即可。
    - 目的：为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源
4. 尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）
    - 注意：图层不要过多设置，否则不但效果没有达到反而更差了

#### 4. 如何⽤webpack来优化前端性能

⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。

- 压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS⽂件，利⽤cssnano （css-loader?minimize）来压缩css。
- 利⽤CDN加速：在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于output参数和各loader的publicPath参数来修改资源路径
- Tree Shaking：将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现
- Code Splitting：将代码按路由维度或者组件分块(chunk)，这样做到按需加载，同时可以充分利⽤浏览器缓存
- 提取公共第三⽅库：SplitChunksPlugin插件来进⾏公共模块抽取，利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码