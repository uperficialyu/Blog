## 目录

1. http和https的区别
2. 协商缓存和强缓存的区别
3. tcp的三次握手和四次挥手
4. 为什么挥手需要四次
5. 2MSL等待状态出现的原因

#### 1. http和https的区别

TTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS和HTTP的区别主要如下：

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### 2. 协商缓存和强缓存的区别

强缓存

强缓存离不开两个响应头Expires与Cache-Control

- Expires：Expires是http1.0提出的⼀个表示资源过期时间的header，它描述的是⼀个绝对时间，由服务器返回，Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效
    - Expires: Wed, 11 May 2018 07:20:00 GMT
- Cache-Control：Cache-Control出现于HTTP/1.1，优先级⾼于Expires，表示的是相对时间
    - Cache-Control: max-age=315360000

⽬前主流的做法使⽤Cache-Control控制缓存，除了max-age控制过期时间外，还有⼀些不得不提：

- Cache-Control：public可以被所有⽤户缓存，包括终端和CDN等中间代理服务器
- Cache-Control：private只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存
- Cache-Control：no-cache，先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤
- Cache-Control：no-store，不会产⽣任何缓存

在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。

协商缓存

- 当第⼀次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期抑或它的属性设置为no-cache时，那么浏览器第⼆次请求时就会与服务器进⾏协商。
- 如果缓存和服务端资源的最新版本是⼀致的，那么就⽆需再次下载该资源，服务端直接返回304 Not Modified状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok。

服务器判断缓存是否是新鲜的⽅法就是依靠HTTP的另外两组信息

Last-Modified/If-Modified-Since

客户端⾸次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT通过响应部⾸发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，如果服务器的资源更新，那么返回最新的资
源，此时状态码200，当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回304状态码，表示客户端直接⽤缓存即可。

ETag/If-None-Match

ETag的流程跟Last-Modified是类似的，区别就在于ETag是根据资源内容进⾏hash，⽣成⼀个信息摘要，只要资源内容有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，这⽐Last-Modified的精确度要更⾼。

#### 3. tcp的三次握手和四次挥手

##### 三次握手

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

| 行为 | 事件 | client状态 | server状态 |
| -- | -- | -- | -- |
| 初始 | --- | closed | listen |
| 第一次握手 | client发送SYN给server，携带ISN序列号 | SYN_SEND | listen |
| 第二次握手 | server收到SYN报文以自己的SYN作为应答，客户端ISN+1作为ACK | SYN_SEND | SYN_RCVD |
| 第三次握手 | client收到server发来的ACK和SYN，再发一个ACK（ISN再+1） | ESTABLISHED | ESTABLISHED |

- 第⼀次握⼿(SYN=1, seq=x)：

客户端发送⼀个TCP的SYN标志位置1的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号(Sequence Number)字段⾥。发送完毕后，客户端进⼊SYN_SEND状态。

- 第⼆次握⼿(SYN=1, ACK=1, seq=y, ACKnum=x+1)：

服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1。服务器端选择⾃⼰ISN序列号，放到Seq域⾥，同时将确认序号(Acknowledgement Number)设置为客户的ISN加1，即X+1。发送完毕后，服务器端进⼊SYN_RCVD状态。

- 第三次握⼿(ACK=1， ACKnum=y+1)：

客户端再次发送确认包(ACK)，SYN 标志位为0 ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写ISN的+1发送完毕后，客户端进⼊ESTABLISHED状态，当服务器端接收到这个包时，也进⼊ESTABLISHED状态，TCP握⼿结束。

##### 四次挥手

TCP的连接的拆除需要发送四个包，因此称为四次挥⼿(Four-way handshake)，也叫做改进的三次握⼿。客户端或服务器均可主动发起挥⼿动作，在socket编程中， 任何⼀⽅执⾏close()操作即可产⽣挥⼿操作。

- 第⼀次挥⼿(FIN=1，seq=x)

假设客户端想要关闭连接，客户端发送⼀个FIN标志位置为1的包，表示⾃⼰已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进⼊FIN_WAIT_1 状态。

- 第⼆次挥⼿(ACK=1， ACKnum=x+1)

服务器端确认客户端的FIN包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进⼊CLOSE_WAIT状态， 客户端接收到这个确认包之后，进⼊FIN_WAIT_2状态，等待服务器端关闭连接。

- 第三次挥⼿(FIN=1， seq=y)

发送完毕后，服务器端进⼊LAST_ACK状态，等待来⾃客户端的最后⼀个ACK。

- 第四次挥⼿(ACK=1， ACKnum=y+1)

客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊TIME_WAIT状态，等待可能出现的要求重传的ACK包。服务器端接收到这个确认包之后，关闭连接，进⼊CLOSED状态。客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊CLOSED状态。

#### 4. 为什么挥手需要四次

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

#### 5. 2MSL等待状态出现的原因

1. TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
2. **为了保证客户端发送的最后一个ACK报文段能够到达服务器。**因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。



3、	webpack的打包流程
6、	vue的双向绑定
7、	项目介绍
8、	css两边固定，中间自适应
9、	垂直居中布局
10、treeshaking
